\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{tikz-cd}
\usepackage[margin=2.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{question}{Question}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\iss}[1]{\mathcal{#1}_S}
\newcommand{\isc}[1]{\mathcal{#1}_C}
\newcommand{\isr}[1]{\mathcal{#1}_R}
\newcommand{\ist}[1]{\mathcal{#1}_t}

\DeclareMathOperator{\Fam}{Fam}

\title{\vspace{-2cm}Memory Manipulation}

\begin{document}
    \maketitle

    \section*{Thoughts on this document}

    The basic example is an interaction structure that tracks the amount of memory currently available and has
    operations for allocating, deallocating, writing, and reading memory.  We can show how this can be implemented in a
    straightforward way in an indexed state monad.  It may also be interesting to show how we can implement this in a
    non-indexed state monad.

    A minor variation on this example is to allow the use of arbitrary indices in the read and write operations, losing
    some type safety.

    A good introduction may be to first show how this example plays out in the non-dependent case, and what kind of
    complaining Agda does about that.  This is good motivation for introducing indexed monads.  (Do we want motivation?
    Is just saying ``These are the things we work with'' not better?  It becomes so wishy-washy this way.)

    I already have a definition of interaction structures, in mathematical terms.  Do I want to duplicate the work by
    describing it in Agda terms, too?

    We keep calling free monads free, but really we need some kind of equivalence to show this; there is no clear
    `forgetful' structure here.  What do indexed free monads even mean?  Does every indexed functor extend to a free
    monad?

    I think the best way to go is to first introduce everything (perhaps abstractly?) and then show how it works with an
    example (plus the implementation in Agda, if omitted).  On the other hand, implementing everything in Agda
    immediately may be beneficial?

    \section{Memory Motivation}

    We can model a program that operates on a block of raw memory by representing the following four operations:
    \begin{description}
        \item[Allocating] a new memory cell;
        \item[Deallocating] the last allocated memory cell;
        \item[Writing] a value to an existing memory cell; and
        \item[Reading] a value from an existing memory cell.
    \end{description}

    If we were working in Haskell, we could implement these operations as terms in a state monad.  However, in order for
    these operations to be meaningful, a number of preconditions must be satisfied: in particular, we cannot deallocate
    memory if there are no cells allocated, and all reads and writes must be within the bounds of the array.  A state
    monad with state type |List Nat| does not give us enough information on the type level to rule out these uses, since
    we can sequence any two terms in this monad.

    The problem lies in the requirement that the bind of a monad work for any continuation.
\end{document}
