\documentclass{report}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%

\title{Research Proposal: Formalisation of Cryptographic Proofs in Agda}
\author{By Anton Golov,\\under the supervision of\\Jaap van Oosten, Wouter Swiestra, and Victor Miraldo}

\begin{document}
    \maketitle

    \begin{abstract}
        Given an encryption scheme, it is desirable to show that it is secure against particular forms of attack.  For
        my thesis, I wish to develop a library for the Agda programming language which would aid in expressing proofs of
        this nature.
    \end{abstract}
    \tableofcontents

    \chapter{Introduction}

% Outline:
% Example of an encryption scheme.
% Problem: how do we quantify how secure this is?
% Example attack: Eavesdropping.
% Example attack: Chosen Plaintext Attack
% Formalisation in Agda
% Existing work

% TODO: Write some kind of introduction to the problem as a whole.

\section{Example: One-Time Pad}

We can define an encryption scheme in Haskell as follows:
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{generateKey}\mathbin{::}\Conid{Int}\to \Conid{IO}\;\Conid{BitVector}{}\<[E]%
\\
\>[5]{}\Varid{generateKey}\;\Varid{n}\mathrel{=}\Varid{fromBits}\;(\Varid{replicateM}\;\Varid{n}\;\Varid{randomIO}){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Varid{encrypt}\mathbin{::}\Conid{BitVector}\to \Conid{BitVector}\to \Conid{BitVector}{}\<[E]%
\\
\>[5]{}\Varid{encrypt}\;\Varid{key}\;\Varid{msg}\mathrel{=}\Varid{least}\;(\Varid{size}\;\Varid{msg})\;(\Varid{xor}\;\Varid{key}\;\Varid{msg}){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Varid{decrypt}\mathbin{::}\Conid{BitVector}\to \Conid{BitVector}\to \Conid{BitVector}{}\<[E]%
\\
\>[5]{}\Varid{decrypt}\mathrel{=}\Varid{encrypt}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

However, can we say anything about the security of this scheme?  In the rest of this section, we will define two
conditions of security and show that this scheme satisfies the weaker but not the stronger of the two.

% TODO: Something about the proofs being brittle?

\subsection{Eavesdropper Attack}

Suppose that Alice and Bob wish to use this encryption scheme to send a single message over an insecure channel.  

\subsection{Chosen-Plaintext Attack}
\subsection{}



% For example, consider the One-Time Pad encryption scheme for bitstrings of length $n$: to generate a key we take a
% random bitstring $k$ of length $n$, and to encrypt or decrypt the message $m$ we take the XOR $k \oplus m$.  One
% `game' we can play goes as follows: we generate a key $k$ and let the adversary choose two messages $m_1$ and $m_2$.
% We then flip a coin and encrypt $m_1$ if it is heads and $m_2$ if it is tails, and give the encrypted message to the
% adversary, who must tell us whether the coin landed heads or tails.  If the adversary answers correctly, they win;
% otherwise, they lose.
% 
% We say that the One-Time Pad encryption scheme is secure to Eavesdropping if any adversary has at most 1/2
% probability of winning in the above game.  It turns out that this does indeed hold for the One-Time Pad.  A stronger
% version of this condition we may want to look at is whether this is still the case if the adversary may first
% encrypt any number of strings; this is called security against a Chosen-Plaintext Attack, and it turns out that the
% One-Time Pad is \emph{not} secure against it.
% 
% To prove such a property, one typically constructs a sequence of games, where the probability of an adversary
% winning only improves by at most some very small value in each transition.  The final game in the construction is
% typically one where the probability is clear: for example, if whether the adversary wins or loses does not depend on
% the choice made by the adversary.
% 
% The aim of this research project is to create a system in which both encryption schemes and such proofs of security
% can be expressed and automatically verified.  This system will be built on top of the Agda programming language,
% allowing the prover to use other Agda libraries, and allowing this system to be used in larger Agda programs.

\section{Formalised Proofs}

\section{Existing Work}

The game-playing approach to cryptographic proofs is an existing and popular technique~\cite{codebasedgames}.

There are several systems for expressing cryptographic proofs in Coq or in special-purpose
languages\footnote{EasyCrypt, FCF}.  However, these all put the imperative style that cryptographic algorithms are
typically written in at the forefront, which shapes the remainder of the system.  We intend to put more focus on the
search for an elegant type-theoretic formulation of these properties, which should make the resulting proofs more
elegant.

TODO: Stochastic lambda calculus papers, dist monad papers?
    \chapter{Game-Playing Proofs}

% Outline:
% Historic background
% Notion of an adversary [later: of an oracle]
% Standard game definitions
    \chapter{Game Syntax}

% Outline:
% Programs as syntactic constructions.


    \chapter{Probability in Agda}

% Outline:
% Probability in mathematics.
% Postulate a Probability type.
% Two common ways of expressing a probability: list of probabilities or measure-theoretic.
% Valuation of syntax.
    % These are for the final thesis:
    % \include{05-proof-techs}
    % \include{06-examples}
    \chapter{Research Plan}

% Outline:
% Oracles, more games
% Security up to some epsilon
% Security relative to a hard problem
% Polynomial-time oracles

We have now created a basic version of the system in which we can reason about the security of the One-Time Pad
construction described above, and show that it is secure with respect to the Eavesdropper attack.  The proofs are
incredibly verbose, but the properties we are looking for hold.  

Further work is necessary to express more complicated games, for example where the adversary has access to a
(stateful) oracle\footnote{TODO: define oracle}.  We also expect to be able to greatly improve the readability of
proofs and reduce the need for repetition in them.

Momentarily, the the formulation of the security conditions require security to be absolute---it must be impossible
for the adversary to do better than exactly random chance.  It is, in fact, of more interest to allow for some small
`advantage', as long as it is asymptotically vanishing or at least bounded by some small constant.  Finding elegant
ways to express this will be a considerable part of the project.

Finally, in practice it is often interesting to consider only polynomial-time adversaries.  Due to the opaque nature
of functions in Agda this will be a challenge to implement, but would be an interesting endeavour if there is
time remaining.

\section{Timetable and Planning}

TODO: Write neat text.
\begin{itemize}
    \itemsep0em
    \item February-March: expressing games, expressing encryption schemes, expressing proof techniques
    \item April-May: proving stronger results, start writing thesis (prior knowledge)
    \item June: write thesis (my results), prove leftover postulates, express things like polynomial-time adversaries
    \item July: integrate last results into thesis, correct last
\end{itemize}


    \bibliography{proposal}
    \bibliographystyle{alpha}
\end{document}
