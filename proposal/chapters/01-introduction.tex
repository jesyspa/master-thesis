\chapter{Introduction}

Given a (possibly non-deterministic) function $f : A \to B$, we say that it is an encryption function iff
\begin{enumerate}
    \itemsep0em
    \item There is a function $g : B \to A$ such that $g \circ f$ is the identity.
    \item Given a $b \in B$, it is hard to find an $a \in A$ such that $f(a) = b$ if $g$ is not known.
\end{enumerate}

The first of these properties is easy to formulate, verify and prove.  The second, on the other hand, is not formal
claim at all.  The goal of this chapter is to show how it can be expressed in objective measures using games,
progressively adding complexity to the system until we can express everything we want to.

In this chapter, we present a simplified system in Haskell which captures many of the computational features we care
about, but in which we cannot express the proofs that we want to reason about.  The rest of this thesis will be
dedicated to formalising both the computations and the proofs involved in Agda, resulting in a library in which these
properties can be proved for further algorithms.

The reader may note that we completely omit discussion of oracles from this chapter.  Oracles are an essential topic,
and their incorporation in the system we construct is one of the main goals for the coming months.  Chapter
\ref{chp:research-plan} contains a brief overview of the progress so far and our plans for the coming months.

\section{Games as Security Levels}

Suppose that we have three parties, Alice, Bob, and Eve.  Alice and Bob have agreed on a key in advance, which Eve does
not know, and are sending each other messages encrypted with that key.  Suppose that Eve intercepts one such message:
what information can she gain based on this?

In order to consider the worst possible case, we will allow Eve to choose two plaintext messages and let the intercepted
message be the ciphertext of one of them.  If Eve cannot tell which message was encrypted even in this scenario, then
she also cannot tell the difference when the message was chosen from some larger set, and we can be certain that Eve
cannot distinguish between the ciphertexts of messages chosen from some larger set.

We can describe the game as follows:
\begin{enumerate}
    \itemsep0em
    \item Alice chooses a key $k$.
    \item Eve chooses two messages, $m_0$ and $m_1$, and gives them to Alice.
    \item Alice flips a coin and gets a result $b \in \{0, 1\}$.
    \item Alice encrypts $m_b$ and gives the result, $m'$, to Eve.
    \item Eve chooses $b' \in \{0, 1\}$ and gives it to Alice.
    \item If $b = b'$ then Eve wins, otherwise Eve loses.
\end{enumerate}

Note that Bob does not figure in this interaction, since his actions don't influence the information Eve has.  As far as
we are concerned, this is a two-player game between the encrypter, Alice, and the eavesdropper, Eve.  The encrypter is
typically called the challenger, while the eavesdropper is called the attacker or the adversary.  We will from now on
describe games from the point of view of the challenger, while treating the adversary as a black box.  The above game
thus becomes:
\begin{enumerate}
    \itemsep0em
    \item Generate a key $k$.
    \item Receive messages $m_0$ and $m_1$ from the adversary.
    \item Flip a coin to get $b \in \{0, 1\}$.
    \item Encrypt $m_b$; call the result $m'$.
    \item Give the adversary $m'$ and get $b'$ back.
    \item Return $b = b'$.
\end{enumerate}

This can, in turn, be regarded as a program in some imperative language, or a computation in some monad.  Computations
performed by the challenger are known, so they can be directly encoded in the program.  Computations performed by the
adversary are given as parameters to the program.  For the moment, we will use Haskell to represent these computations
and assume that there is a monad |Game| that provides some source of randomness and some way for the adversary to
store its state.
\begin{code}
data EncScheme key pt ct = EncScheme
                         { generateKey :: Game key
                         , encode :: key -> pt -> Game ct
                         }

data Adversary pt ct = Adversary
                     { chooseMessages :: Game (pt, pt)
                     , chooseOutcome :: ct -> Game Bool
                     }

EAV_game :: EncScheme key pt ct -> Adversary pt ct -> Game Bool
EAV_game enc adv = do
    k <- generateKey enc
    (m0, m1) <- chooseMessages adv
    b <- flipCoin
    m' <- encode enc k (if b then m1 else m0)
    b' <- chooseOutcome adv m'
    return (b == b')
\end{code}

We now have a precise description of the game involved, and we can say that a scheme |enc| is secure against
eavesdropping iff |EAV_game enc adv| is `very close' to |flipCoin| for every choice of |adv|.  We will now give a more
rigorous definition of the |Game| monad in order to formalise this notion of distance.

\section{The |Game| Monad}

In the last section, we showed how games can be seen as terms in some |Game| monad.  This monad represented a
computation that may use some random bits, and in which the adversary may manipulate their state.  This computation can
be interpreted into a concrete value given an initial state and an (infinite) sequence of random bits.

The adversary should be free to choose what type they wish to use for their state, while the challenger should be unable
to in any way access or modify this state.  We can achieve this by parametrising |Adversary| by its state type, while
requiring that our encryption work for any adversary state type.  The example above then becomes
\begin{code}
data EncScheme key pt ct = EncScheme
                         { generateKey :: forall as. Game as key
                         , encode :: forall as. key -> pt -> Game as ct
                         }

data Adversary as pt ct = Adversary
                        { chooseMessages :: Game as (pt, pt)
                        , chooseOutcome :: ct -> Game as Bool
                        }

EAV_game :: EncScheme key pt ct -> Adversary as pt ct -> Game as Bool
EAV_game enc adv = do
    ... -- unchanged
\end{code}

Since the challenger has no information about |as|, they cannot perform any operation on it; there is also no way for
|generateKey| to somehow store the state to later use it in |encode|.

\subsection{Operations}

There are three classes of operations supported by the |Game| monad: operations involving randomness, which may
be performed by both challenger and adversary, operations manipulating the adversary's state, which may only be
performed by the adversary, and operations manipulating oracle state, which may only be performed by the challenger.
Since we are not yet concerned with oracles, we will only cover the first two categories.

The fundamental operation involving randomness is the flipping of a fair coin.  From this we can build up random
bitstrings of any length.  We have so far not provided any way of generating uniform distributions over sets with a size
other than a power of two, as this does not seem to be a common requirement in the domain of cryptography.  The
resulting operations provided are thus:
\begin{code}
fairCoin :: Game as Bool
uniform :: Int -> Game BitVector
\end{code}

In addition to the above, the FCF provides a |repeat| operation which repeats some non-deterministic computation until a
predicate holds on the result.  More research is needed to see whether this is truly necessary for our purposes.

The adversary is given access to a state, which acts much like the state of a state monad.  There are corresponding
operations:
\begin{code}
getAdvState :: Game as as
putAdvState :: as -> Game as ()
\end{code}




\subsection{Interpretation}



% Introduction
% What can we do?
% What can the adversary do?
% How can we interpret it?


\section{Security Constraints}



\section{Example: One-Time Pad}

We can define an encryption scheme in Haskell as follows:
\begin{code}
    generateKey :: Int -> Game BitVector
    generateKey = uniform

    encrypt :: BitVector -> BitVector -> Game BitVector
    encrypt key msg = return (least (size msg) (xor key msg))
\end{code}

However, can we say anything about the security of this scheme?  In the rest of this section, we will define two
conditions of security and show that this scheme satisfies the weaker but not the stronger of the two.

\subsection{}

\subsection{Chosen-Plaintext Attack}

Not secure.


% For example, consider the One-Time Pad encryption scheme for bitstrings of length $n$: to generate a key we take a
% random bitstring $k$ of length $n$, and to encrypt or decrypt the message $m$ we take the XOR $k \oplus m$.  One
% `game' we can play goes as follows: we generate a key $k$ and let the adversary choose two messages $m_1$ and $m_2$.
% We then flip a coin and encrypt $m_1$ if it is heads and $m_2$ if it is tails, and give the encrypted message to the
% adversary, who must tell us whether the coin landed heads or tails.  If the adversary answers correctly, they win;
% otherwise, they lose.
% 
% We say that the One-Time Pad encryption scheme is secure to Eavesdropping if any adversary has at most 1/2
% probability of winning in the above game.  It turns out that this does indeed hold for the One-Time Pad.  A stronger
% version of this condition we may want to look at is whether this is still the case if the adversary may first
% encrypt any number of strings; this is called security against a Chosen-Plaintext Attack, and it turns out that the
% One-Time Pad is \emph{not} secure against it.
% 
% To prove such a property, one typically constructs a sequence of games, where the probability of an adversary
% winning only improves by at most some very small value in each transition.  The final game in the construction is
% typically one where the probability is clear: for example, if whether the adversary wins or loses does not depend on
% the choice made by the adversary.
% 
% The aim of this research project is to create a system in which both encryption schemes and such proofs of security
% can be expressed and automatically verified.  This system will be built on top of the Agda programming language,
% allowing the prover to use other Agda libraries, and allowing this system to be used in larger Agda programs.

\section{Formalised Proofs}

Writing proofs on paper is error-prone.  Let's use a proof-assistant to make sure that what we write is actually
correct.

\section{Existing Work}

The game-playing approach to cryptographic proofs is an existing and popular technique~\cite{codebasedgames}.

There are several systems for expressing cryptographic proofs in Coq or in special-purpose
languages\footnote{EasyCrypt, FCF}.  However, these all put the imperative style that cryptographic algorithms are
typically written in at the forefront, which shapes the remainder of the system.  We intend to put more focus on the
search for an elegant type-theoretic formulation of these properties, which should make the resulting proofs more
elegant.

TODO: Stochastic lambda calculus papers, dist monad papers?
