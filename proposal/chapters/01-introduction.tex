\chapter{Introduction}

% Outline:
% Example of an encryption scheme.
% Problem: how do we quantify how secure this is?
% Example attack: Eavesdropping.
% Example attack: Chosen Plaintext Attack
% Formalisation in Agda
% Existing work

% TODO: Write some kind of introduction to the problem as a whole.

\section{Example: One-Time Pad}

We can define an encryption scheme in Haskell as follows:
\begin{code}
    generateKey :: Int -> IO BitVector
    generateKey n = fromBits (replicateM n randomIO)

    encrypt :: BitVector -> BitVector -> BitVector
    encrypt key msg = least (size msg) (xor key msg)

    decrypt :: BitVector -> BitVector -> BitVector
    decrypt = encrypt
\end{code}

However, can we say anything about the security of this scheme?  In the rest of this section, we will define two
conditions of security and show that this scheme satisfies the weaker but not the stronger of the two.

% TODO: Something about the proofs being brittle?

\subsection{Eavesdropper Attack}

Suppose that we have three parties, Alice, Bob, and Eve.  Alice and Bob have agreed on a key in advance, which Eve does
not know, and are sending each other messages encrypted with that key.  Suppose that Eve intercepts one such message:
what can she deduce based on this?

In order to consider the worst possible case, we will allow Eve to choose two plaintext messages and let the intercepted
message be the ciphertext of one of them.  If Eve cannot tell which message was encrypted even in this scenario, then
she also cannot tell the difference when the message could have been anything, and we can be certain that the scheme is
secure against this kind of attack.

We can describe the game as follows:
\begin{enumerate}
    \itemsep0em
    \item Alice chooses a key $k$.
    \item Eve chooses two messages, $m_0$ and $m_1$, and gives them to Alice.
    \item Alice flips a coin and gets a result $b \in \{0, 1\}$.
    \item Alice encrypts $m_b$ and gives the result, $m'$, to Eve.
    \item Eve chooses $b' \in \{0, 1\}$ and gives it to Alice.
    \item If $b = b'$ then Eve wins, otherwise Eve loses.
\end{enumerate}

Note that Bob does not figure in this interaction, since his actions don't influence the information Eve has.  As far as
we are concerned, this is a two-player game between the encrypter, Alice, and the eavesdropper, Eve.  The encrypter is
typically called the challenger, while the eavesdropper is called the attacker or the adversary.  We will from now on
describe games from the point of view of the challenger, while treating the adversary as a black box.  The above game
thus becomes:
\begin{enumerate}
    \itemsep0em
    \item Generate a key $k$.
    \item Receive messages $m_0$ and $m_1$ from the adversary.
    \item Flip a coin to get $b \in \{0, 1\}$.
    \item Encrypt $m_b$; call the result $m'$.
    \item Give the adversary $m'$ and get $b'$ back.
    \item Return $b = b'$.
\end{enumerate}



\subsection{Chosen-Plaintext Attack}

Not secure.


% For example, consider the One-Time Pad encryption scheme for bitstrings of length $n$: to generate a key we take a
% random bitstring $k$ of length $n$, and to encrypt or decrypt the message $m$ we take the XOR $k \oplus m$.  One
% `game' we can play goes as follows: we generate a key $k$ and let the adversary choose two messages $m_1$ and $m_2$.
% We then flip a coin and encrypt $m_1$ if it is heads and $m_2$ if it is tails, and give the encrypted message to the
% adversary, who must tell us whether the coin landed heads or tails.  If the adversary answers correctly, they win;
% otherwise, they lose.
% 
% We say that the One-Time Pad encryption scheme is secure to Eavesdropping if any adversary has at most 1/2
% probability of winning in the above game.  It turns out that this does indeed hold for the One-Time Pad.  A stronger
% version of this condition we may want to look at is whether this is still the case if the adversary may first
% encrypt any number of strings; this is called security against a Chosen-Plaintext Attack, and it turns out that the
% One-Time Pad is \emph{not} secure against it.
% 
% To prove such a property, one typically constructs a sequence of games, where the probability of an adversary
% winning only improves by at most some very small value in each transition.  The final game in the construction is
% typically one where the probability is clear: for example, if whether the adversary wins or loses does not depend on
% the choice made by the adversary.
% 
% The aim of this research project is to create a system in which both encryption schemes and such proofs of security
% can be expressed and automatically verified.  This system will be built on top of the Agda programming language,
% allowing the prover to use other Agda libraries, and allowing this system to be used in larger Agda programs.

\section{Formalised Proofs}

Writing proofs on paper is error-prone.  Let's use a proof-assistant to make sure that what we write is actually
correct.

\section{Existing Work}

The game-playing approach to cryptographic proofs is an existing and popular technique~\cite{codebasedgames}.

There are several systems for expressing cryptographic proofs in Coq or in special-purpose
languages\footnote{EasyCrypt, FCF}.  However, these all put the imperative style that cryptographic algorithms are
typically written in at the forefront, which shapes the remainder of the system.  We intend to put more focus on the
search for an elegant type-theoretic formulation of these properties, which should make the resulting proofs more
elegant.

TODO: Stochastic lambda calculus papers, dist monad papers?
